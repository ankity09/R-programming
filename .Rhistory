submit()
telegram("good morning")
submit()
mad_libs(adjective = "", place = "", noun = "") # passing arguments to the above function
submit()
submit()
"I" %p% "love" %p% "R!"
2
exit()
info()
pollutantmean <- function(directory, pollutant, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
dat <- rbind(dat, read.csv(files_full[i]))
}
mean(dat[, pollutant], na.rm = TRUE)
}
pollutantmean(/Users/Ankit/Downloads/specdata,sulfate,17)
pollutantmean(specdata,sulfate,17)
getwd()
pollutantmean(specdata,sulfate,17)
getwd()
pollutantmean(/Users/Ankit/Desktop/Rspecdata,sulfate,17)
pollutantmean(/Users/Ankit/Desktop/R/specdata,sulfate,17)
pollutantmean("specdata",sulfate,17)
pollutantmean("specdata","sulfate",17)
pollutantmean("specdata","sulfate",1:10)
}
complete <- function(directory, id = 1:332) {
complete <- function(directory, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
moni_i <- read.csv(files_full[i])
nobs <- sum(complete.cases(moni_i))
tmp <- data.frame(i, nobs)
dat <- rbind(dat, tmp)
}
colnames(dat) <- c("id", "nobs")
complete <- function(directory, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
moni_i <- read.csv(files_full[i])
nobs <- sum(complete.cases(moni_i))
tmp <- data.frame(i, nobs)
dat <- rbind(dat, tmp)
}
colnames(dat) <- c("id", "nobs")
complete <- function(directory, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
moni_i <- read.csv(files_full[i])
nobs <- sum(complete.cases(moni_i))
tmp <- data.frame(i, nobs)
dat <- rbind(dat, tmp)
}
colnames(dat) <- c("id", "nobs")
dat
}
complete <- function(directory, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
moni_i <- read.csv(files_full[i])
nobs <- sum(complete.cases(moni_i))
tmp <- data.frame(i, nobs)
dat <- rbind(dat, tmp)
}
colnames(dat) <- c("id", "nobs")
dat
}
}
complete("specdata",1)
complete <- function(directory, id = 1:332) {
files_full <- list.files(directory, full.names = TRUE)
dat <- data.frame()
for (i in id) {
moni_i <- read.csv(files_full[i])
nobs <- sum(complete.cases(moni_i))
tmp <- data.frame(i, nobs)
dat <- rbind(dat, tmp)
}
colnames(dat) <- c("id", "nobs")
dat
}
complete("specdata",1)
corr <- function(directory, threshold = 0) {
files_full <- list.files(directory, full.names = TRUE)
dat <- vector(mode = "numeric", length = 0)
for (i in 1:length(files_full)) {
moni_i <- read.csv(files_full[i])
csum <- sum((!is.na(moni_i$sulfate)) & (!is.na(moni_i$nitrate)))
if (csum > threshold) {
tmp <- moni_i[which(!is.na(moni_i$sulfate)), ]
submoni_i <- tmp[which(!is.na(tmp$nitrate)), ]
dat <- c(dat, cor(submoni_i$sulfate, submoni_i$nitrate))
}
}
dat
}
cr <- corr("specdata", 150)
head(cr)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
2
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit(manual=TRUE)
submit(manual=TRUE)
submit(manual=TRUE)
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
library(datasets)
data(iris)
?iris
colnames(iris)
sapply(iris,mean)
apply(iris[, 1:4], 2, mean)
colMeans(iris)
rowMeans(iris[, 1:4])
apply(iris, 2, mean)
library(datasets)
data(mtcars)
?mtcars
mean(mtcars$mpg, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
split(mtcars, mtcars$cyl)
sapply(mtcars, cyl, mean)
colnames(mtcars)
head(mtcars)
tapply(mtcars$hp, mtcars$cyl, mean)
209.21429 - 82.63636
debug(ls)
ls
ls()
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE,
qwq
library(datasets)
data(iris)
mean(iris$Sepal.Length [iris$Species=="virginica"],na.rm=TRUE)
209.21429 - 82.63636
library(datasets)
data(mtcars)
mean(mtcars$mpg, mtcars$cyl)
sapply(mtcars, cyl, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
Outcome <- read.csv("Outcome-of-care-measures.csv", colClasses = "character")
head(Outcome)
best <- function(stateChr, outcomeChr) {
outcomeDfr <- Init("Outcome-of-care-measures.csv")
suppressWarnings(outcomeDfr[, 11] <- as.numeric(outcomeDfr[, 11]))
suppressWarnings(outcomeDfr[, 17] <- as.numeric(outcomeDfr[, 17]))
suppressWarnings(outcomeDfr[, 23] <- as.numeric(outcomeDfr[, 23]))
tableDfr <- data.frame(State = names(tapply(outcomeDfr$State, outcomeDfr$State,
length)), Freq = tapply(outcomeDfr$State, outcomeDfr$State, length))
rownames(tableDfr) <- NULL
inputDfr <- data.frame(Outcome = c("heart attack", "heart failure", "pneumonia"),
Col = c(11, 17, 23))
if (nrow(tableDfr[tableDfr$State == stateChr, ]) == 0)
stop("invalid state")
if (nrow(inputDfr[inputDfr$Outcome == outcomeChr, ]) == 0)
stop("invalid outcome")
stateDfr <- outcomeDfr[outcomeDfr$State == stateChr, ]
colNum <- inputDfr[inputDfr$Outcome == outcomeChr, 2]
rowNum <- which.min(stateDfr[, colNum])
return(stateDfr[rowNum, ]$Hospital.Name)
}
best("TX", "heart attack")
best <- function(stateChr, outcomeChr) {
outcomeDfr <- Init("Outcome-of-care-measures.csv")
suppressWarnings(outcomeDfr[, 11] <- as.numeric(outcomeDfr[, 11]))
suppressWarnings(outcomeDfr[, 17] <- as.numeric(outcomeDfr[, 17]))
suppressWarnings(outcomeDfr[, 23] <- as.numeric(outcomeDfr[, 23]))
tableDfr <- data.frame(State = names(tapply(outcomeDfr$State, outcomeDfr$State,
length)), Freq = tapply(outcomeDfr$State, outcomeDfr$State, length))
rownames(tableDfr) <- NULL
inputDfr <- data.frame(Outcome = c("heart attack", "heart failure", "pneumonia"),
Col = c(11, 17, 23))
if (nrow(tableDfr[tableDfr$State == stateChr, ]) == 0)
stop("invalid state")
if (nrow(inputDfr[inputDfr$Outcome == outcomeChr, ]) == 0)
stop("invalid outcome")
stateDfr <- outcomeDfr[outcomeDfr$State == stateChr, ]
colNum <- inputDfr[inputDfr$Outcome == outcomeChr, 2]
rowNum <- which.min(stateDfr[, colNum])
return(stateDfr[rowNum, ]$Hospital.Name)
}
best("TX", "heart attack")
?Init
library(lattice)
?Init
library(lattice)
Outcome <- read.csv("Outcome-of-care-measures.csv", colClasses = "character")
best <- function(stateChr, outcomeChr) {
outcomeDfr <- Init("Outcome-of-care-measures.csv")
suppressWarnings(outcomeDfr[, 11] <- as.numeric(outcomeDfr[, 11]))
suppressWarnings(outcomeDfr[, 17] <- as.numeric(outcomeDfr[, 17]))
suppressWarnings(outcomeDfr[, 23] <- as.numeric(outcomeDfr[, 23]))
tableDfr <- data.frame(State = names(tapply(outcomeDfr$State, outcomeDfr$State,
length)), Freq = tapply(outcomeDfr$State, outcomeDfr$State, length))
rownames(tableDfr) <- NULL
inputDfr <- data.frame(Outcome = c("heart attack", "heart failure", "pneumonia"),
Col = c(11, 17, 23))
if (nrow(tableDfr[tableDfr$State == stateChr, ]) == 0)
stop("invalid state")
if (nrow(inputDfr[inputDfr$Outcome == outcomeChr, ]) == 0)
stop("invalid outcome")
stateDfr <- outcomeDfr[outcomeDfr$State == stateChr, ]
colNum <- inputDfr[inputDfr$Outcome == outcomeChr, 2]
rowNum <- which.min(stateDfr[, colNum])
return(stateDfr[rowNum, ]$Hospital.Name)
}
best("TX", "heart attack")
??Init
install.packages("lattice")
library(lattice)
?Init
Outcome <- read.csv("Outcome-of-care-measures.csv", colClasses = "character")
best <- function(stateChr, outcomeChr) {
outcomeDfr <- Init("Outcome-of-care-measures.csv")
suppressWarnings(outcomeDfr[, 11] <- as.numeric(outcomeDfr[, 11]))
suppressWarnings(outcomeDfr[, 17] <- as.numeric(outcomeDfr[, 17]))
suppressWarnings(outcomeDfr[, 23] <- as.numeric(outcomeDfr[, 23]))
tableDfr <- data.frame(State = names(tapply(outcomeDfr$State, outcomeDfr$State,
length)), Freq = tapply(outcomeDfr$State, outcomeDfr$State, length))
rownames(tableDfr) <- NULL
inputDfr <- data.frame(Outcome = c("heart attack", "heart failure", "pneumonia"),
Col = c(11, 17, 23))
if (nrow(tableDfr[tableDfr$State == stateChr, ]) == 0)
stop("invalid state")
if (nrow(inputDfr[inputDfr$Outcome == outcomeChr, ]) == 0)
stop("invalid outcome")
stateDfr <- outcomeDfr[outcomeDfr$State == stateChr, ]
colNum <- inputDfr[inputDfr$Outcome == outcomeChr, 2]
rowNum <- which.min(stateDfr[, colNum])
return(stateDfr[rowNum, ]$Hospital.Name)
}
best("TX", "heart attack")
best <- function(state, outcome) {
## Read outcome data
data <- read.csv("outcome-of-care-measures.csv", colClasses = "character",na.strings="Not Available")
## Check that state and outcome are valid
validOutcome = c("heart attack","heart failure","pneumonia")
if (!outcome %in% validOutcome) { stop("invalid outcome")}
validState = unique(data[,7])
if (!state %in% validState) stop("invalid state")
## convert outcome name into column name
fullColName <- c("Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack", "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure", "Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia")
colName <- fullColName[match(outcome,validOutcome)]
## Return hospital name in that state with lowest 30-day death rate
data.state <- data[data$State==state,]
idx <- which.min(as.double(data.state[,colName]))
data.state[idx,"Hospital.Name"]
}
best("TX", "heart attack")
best("TX", "heart failure")
rankhospital <- function(state, outcome, num = "best") {
## Read outcome data
data <- read.csv("outcome-of-care-measures.csv", colClasses = "character",na.strings="Not Available")
## Check that state and outcome are valid
validOutcome = c("heart attack","heart failure","pneumonia")
if (!outcome %in% validOutcome) { stop("invalid outcome")}
validState = unique(data[,7])
if (!state %in% validState) stop("invalid state")
## convert outcome name into column name
fullColName <- c("Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack", "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure", "Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia")
colName <- fullColName[match(outcome,validOutcome)]
## Return hospital name in that state with the given rank 30-day death rate
data.state <- data[data$State==state,]
# order data by outcome
sorted.data.state <- data.state[order(as.numeric(data.state[[colName]]),data.state[["Hospital.Name"]],decreasing=FALSE,na.last=NA), ]
#handle num input
if (num=="best") num = 1
if (num=='worst') num = nrow(sorted.data.state)
#will automatically return NA if num > nrow, as well as if it's some other text value
# if someone passes num < 1, they'll get what's expected
#if (is.numeric(num) & num > nrwo(sorted.data.state) return(NA)
sorted.data.state[num,"Hospital.Name"]
}
rankhospital("TX", "heart failure", 4)
rankhospital("MD", "heart attack", "worst")
rankall <- function(outcome, num = "best") {
## Read outcome data
data <- read.csv("outcome-of-care-measures.csv", colClasses = "character",na.strings="Not Available")
## Check that state and outcome are valid
validOutcome = c("heart attack","heart failure","pneumonia")
if (!outcome %in% validOutcome) { stop("invalid outcome")}
validState = sort(unique(data[,7]))
if (!state %in% validState) stop("invalid state")
## convert outcome name into column name
fullColName <- c("Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack", "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure", "Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia")
colName <- fullColName[match(outcome,validOutcome)]
## For each state, find the hospital of the given rank
hospital<-character(0)
for (i in seq_along(validState)) {
## Return hospital name in that state with the given rank 30-day death rate
data.state <- data[data$State==validState[i],]
# order data by outcome
sorted.data.state <- data.state[order(as.numeric(data.state[[colName]]),data.state[["Hospital.Name"]],decreasing=FALSE,na.last=NA), ]
#handle num input
this.num = num
if (this.num=="best") this.num = 1
if (this.num=='worst') this.num = nrow(sorted.data.state)
hospital[i] <- sorted.data.state[this.num,"Hospital.Name"]
}
## Return a data frame with the hospital names and the (abbreviated) state name
data.frame(hospital=hospital,state=validState,row.names=validState)
}
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best") {
## Read outcome data
data <- read.csv("outcome-of-care-measures.csv", colClasses = "character",na.strings="Not Available")
## Check that state and outcome are valid
validOutcome = c("heart attack","heart failure","pneumonia")
if (!outcome %in% validOutcome) { stop("invalid outcome")}
validState = sort(unique(data[,7]))
if (!state %in% validState) stop("invalid state")
## convert outcome name into column name
fullColName <- c("Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack", "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure", "Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia")
colName <- fullColName[match(outcome,validOutcome)]
## For each state, find the hospital of the given rank
hospital<-character(0)
for (i in seq_along(validState)) {
## Return hospital name in that state with the given rank 30-day death rate
data.state <- data[data$State==validState[i],]
# order data by outcome
sorted.data.state <- data.state[order(as.numeric(data.state[[colName]]),data.state[["Hospital.Name"]],decreasing=FALSE,na.last=NA), ]
#handle num input
this.num = num
if (this.num=="best") this.num = 1
if (this.num=='worst') this.num = nrow(sorted.data.state)
hospital[i] <- sorted.data.state[this.num,"Hospital.Name"]
}
## Return a data frame with the hospital names and the (abbreviated) state name
data.frame(hospital=hospital,state=validState,row.names=validState)
}
head(rankall("heart attack", 20), 10)
head(rankall("heart attack", 20), 10)
rankall <- function(outcome, num = "best") {
## Read outcome data
data <- read.csv("outcome-of-care-measures.csv")
## Check that outcome is valid
if (!((outcome == "heart attack") | (outcome == "heart failure")
| (outcome == "pneumonia"))) {
stop ("invalid outcome")
}
## For each state, find the hospital of the given rank
col <- if (outcome == "heart attack") {
11
} else if (outcome == "heart failure") {
17
} else {
23
}
data[, col] <- suppressWarnings(as.numeric(levels(data[, col])[data[, col]]))
data[, 2] <- as.character(data[, 2])
# Generate an empty vector that will be filled later, row by row, to
# generate the final output.
output <- vector()
states <- levels(data[, 7])
for(i in 1:length(states)) {
statedata <- data[grep(states[i], data$State), ]
orderdata <- statedata[order(statedata[, col], statedata[, 2],
na.last = NA), ]
hospital <- if(num == "best") {
orderdata[1, 2]
} else if(num == "worst") {
orderdata[nrow(orderdata), 2]
} else{
orderdata[num, 2]
}
output <- append(output, c(hospital, states[i]))
}
## Return a data frame with the hospital names and the (abbreviated)
## state name
output <- as.data.frame(matrix(output, length(states), 2, byrow = TRUE))
colnames(output) <- c("hospital", "state")
rownames(output) <- states
output
}
head(rankall("heart attack", 20), 10)
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript3.R")
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
setwd("/Users/Ankit/R-programming")
libraby(swirl)
library(swirl)
swirl()
ls() # to list variables in my workspace
class(plants) # to check the class of the plants variable, tp give us a clue of the overall structure
dim(plants) # to see exactly how many rows and columns there are in plants
nrow(plants) # to see the number of rows in the plant dataframe
ncol(plants) # to see the number of cloumns
object.size(plants) # to see how much space the dataset is occupying in memory
names(plants) # will return a charcter vector of column(i.e. variable) names
head(plants) # will let you preview the top of the dataset
head(plants,10) # to see the first 10 rows of the dataset and not 6 which is the default
tail(plants,15) # is to see the last 15 rows of the dataset
summary(plants) #gives us a summary of how much of the data is present and missing
table(plants$Active_Growth_Period) # to see how many times each value actually occurs
str(plants) # the most useful function dor understanding your data
?sample # to pull up documentation
sample(1:6,4,replace=TRUE) # simulate rolling four six-sided dice
sample(1:6,4,replace=TRUE) # simulate rolling four six-sided dice
sample(1:20,10) # sapmple 10 numbers without replacement
LETTERS
LETTERS # LETTERS is a predefined variable in R containing a vector of all 26 letters of the english alphabet
sample(LETTERS)
flips <- sample(c(0,1),100,replace=TRUE,prob=c(0.3,0.7))  #| Let the value 0 represent tails and the value 1 represent heads. Use sample() to draw a sample of size 100 from the vector c(0,1), with replacement. Since the coin is unfair, we must attach specific probabilities to the values 0 (tails) and 1 (heads) with a fourth argument, prob =c(0.3, 0.7). Assign the result to a new variable called flips.
flips # view contents
sum(flips) # to count the actual number of 1s contained in flips
?rbinom()
?rbinom
rbinom(1, size = 100, prob = 0.7)
flips2 <- rbinom(c(0,1), size = 100, prob = 0.7)
flips2 <- rbinom(100, size = 1, prob = 0.7)
flips2
sum(flips2)
?rnorm
rnorm(10) # trial
rnorm(mean=100,sd=25) # with mean =100 and a standard deviation =25
rnorm(10,mean=100,sd=25) # with mean =100 and a standard deviation =25
?rpois
rpois(5,mean=10) # to create a poisson distribution
rpois(5,lambda=10) # to create a poisson distribution
my_pois <-replicate(100,rpois(5,lambda=10))
my_pois <-replicate(100,rpois(5,10))
my_pois
colMeans(my_pois) # to get column means
cm <- colMeans(my_pois) # to get column means
hist(cm) # to create a histogram
d1 <- Sys.Date() # get the current data and store it in a variable
class(d1) # to fetch the class of d1
unlcass(d1) # to see what d1 looks like internally
unclass(d1) # to see what d1 looks like internally
d1 # print d1
d2 <- as.Date("1969,01,01") # create a date prior to 1970-01-01
d2 <- as.Date("1969-01-01") # create a date prior to 1970-01-01
unclass(d2)
t1 <- Sys.time() # to get the current time
t1 # view the contents of t1
class(t1) # check the class of t1
unlcass(t1) # to see what t1 looks like internally
unclass(t1) # to see what t1 looks like internally
t2 <- as.POSIXlt(Sys.time()) #  By default, Sys.time() returns an object of class POSIXct, but we can coerce the result to POSIXlt with as.POSIXlt(Sys.time()). Give it a try and
class(t2)
t2
unclass(t2)
str(unclass(t2)) # to have a more compact view of t2
t2$min
weekdays(d1) # weekdays will return the day of the week from any date or time object
months(t1) # months like weekdays will also work on any form of date or time object
quarters(t2) # same as above but for quarters
t3 <- "October 17, 1986 08:24"
t4 <- strptime(t3,"%B %d,%Y %H:%M") # to help R convert our date/time object to a format that it understands
t4 <- strptime(t3,"%B %d, %Y %H:%M") # to help R convert our date/time object to a format that it understands
t4
class(t4)
Sys.time() > t1 # compare the current time with t1
Sys.time() - t1 # subtract the current time from t1
difftime(Sys.time ,t1,units = 'days') # to find the amount of time in DAYS that has passed since you created t1
difftime(Sys.time(),t1,units = 'days') # to find the amount of time in DAYS that has passed since you created t1
data(cars) # load included dataframe cars
?cars # help page for cars
head(cars) # to view the first 6 lines of cars
plot(cars) #
?plot
plot(x=cars$speed,y=cars$dist) # plot to show speed on the x-axis and dist on the y-axis from the cars data frame
plot(x=cars$dist,y=cars$speed) # opposite of what we did above
plot(x=cars$speed,y=cars$dist) # plot to show speed on the x-axis and dist on the y-axis from the cars data frame
plot(x = cars$speed,y = cars$dist , xlab = "Speed") # to create a plot with xlabel as Speed
plot(x = cars$speed,y = cars$dist , xlab = "Speed",ylab = "Stopping Distance") # to create a plot with y label as Stopping distance
plot(x = cars$speed,y = cars$dist,ylab = "Stopping Distance") # to create a plot with y label as Stopping distance
plot(x = cars$speed,y = cars$dist,xlab= "Speed,"ylab = "Stopping Distance,") # to create a plot with y label as Stopping distance
plot(x = cars$speed,y = cars$dist,xlab= "Speed" , ylab = "Stopping Distance,") # to create a plot with y label as Stopping distance
plot(x = cars$speed,y = cars$dist,xlab= "Speed" , ylab = "Stopping Distance") # to create a plot with y label as Stopping distance
plot(x = cars$speed,y = cars$dist,xlab= "Speed" , ylab = "Stopping Distance",main="My Plot") # add a title My Plot
plot(cars,main= "My Plot")
plot (cars,sub="My Plot Subtitle")
plot(cars,col=2) # the plotted points are colored red
plot(cars,xlim=c(10,15)) # plot cars while limiting x-axis to 10 through 15
plot(cars,pch =2) # plot cars using triangles
dara(mtcars) # load the mtcars dataframe
data(mtcars) # load the mtcars dataframe
?boxplot()
?boxplot
boxplot(formula = mpg ~ cyl,data = mtcars) # use boxplot with formula and data = mtcars
hist(mtcars$mpg) #  to create a histogram
